<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unidad 2: Estructura y funcionamiento del CPU</title>
  <link rel="stylesheet" href="U2.css">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <header>
    <nav>
      <img src="../U2/IMAGENES U2/tec logo.png" alt="Logo">
      <ul>
        <li><a href="../Menu/Menu.html">Inicio</a></li>
        <li><a href="../U1/U1.html">Unidad 1</a></li>
        <li><a href="U2.html">Unidad 2</a></li>
        <li><a href="../U3/U3.html">Unidad 3</a></li>
        <li><a href="../U4/U4.html">Unidad 4</a></li>
        <li><a href="../PRACTICAS/practicas.html">Practicas</a></li>
      </ul>
    </nav>
  </header>

  <main class="main-container">
    <aside class="sidebar">
      <h2 onclick="toggleMenu()">Unidad 2: Estructura y funcionamiento del CPU</h2>
      <ul id="sidebar-menu" class="collapsed">
        <li><a href="#OP">2.1 Organización del procesador</a></li>
        <li><a href="#ER">2.2 Estructura de registros</a></li>
        <li><a href="#RVU">2.2.1 Registros visibles para el usuario</a></li>
        <li><a href="#RCE">2.2.2 Registros de control y de estados</a></li>
        <li><a href="#EJR">2.2.3 Ejemplos de registros de CPU reales</a></li>
        <li><a href="#CI">2.3 El ciclo de instrucción</a></li>
        <li><a href="#CIF">2.3.1 Ciclo Fetch-Decode-Execute</a></li>
        <li><a href="#SI">2.3.2 Segmentación de instrucciones</a></li>
        <li><a href="#CICF">2.3.3 Conjunto de instrucciones, Caracteristicas y funciones</a></li>
        <li><a href="#MD">2.3.4 Modos de direccionamiento</a></li>
        <li><a href="#CCPUR">2.4 Casos de estudio de CPU reales</a></li>
      </ul>
    </aside>

    <section class="content">
      <h1>Unidad 2: Estructura y funcionamiento del CPU</h1>

      <!-- temas -->
      <article id="OP">
        <h2>2.1 Organización del procesador</h2>
        <img src="../U2/IMAGENES U2/tema1.jpg" alt="OP">
        <p>
          La organización del procesador, también conocida como arquitectura del procesador o microarquitectura, 
          se refiere al diseño interno y la estructura de un procesador de computadora. Este tema abarca diversos aspectos técnicos y conceptuales que determinan cómo un procesador ejecuta instrucciones, 
          maneja datos y se comunica con otros componentes del sistema. Aquí se explican algunos de los conceptos clave relacionados con la organización del procesador:

          <h3>Unidad de Control:</h3>
          La unidad de control es responsable de interpretar las instrucciones del programa y generar las señales necesarias para ejecutarlas. 
          Coordina las operaciones de los demás componentes del procesador, como la ALU, los registros y las unidades de memoria.

          <h3>Unidad Aritmético-Lógica (ALU):</h3>
          La ALU es la parte del procesador que realiza operaciones aritméticas (como suma y resta) y lógicas (como AND, OR y NOT). 
          Es un componente crucial para la ejecución de cálculos y la toma de decisiones lógicas.
        </p>
      </article>

      <article id="ER">
        <h2>2.2 Estructura de registros</h2>
        <img src="../U2/IMAGENES U2/tema2.png" alt="OP">
        <p>
          Los registros de la CPU son pequeñas unidades de almacenamiento de alta velocidad situadas dentro del procesador. 
          Se utilizan para almacenar temporalmente datos e instrucciones durante la ejecución de programas. 
          Los registros permiten al procesador acceder a datos de manera extremadamente rápida, mucho más rápido que acceder a la memoria RAM. 
          Entre las características clave de los registros se incluyen su capacidad de almacenamiento limitada, generalmente de unos pocos bytes, y su velocidad, 
          que está optimizada para operaciones rápidas y eficientes. Existen diferentes tipos de registros, como los de propósito general, que se utilizan para operaciones aritméticas y lógicas, 
          y los especializados, como el contador de programa (PC), que lleva la cuenta de la dirección de la siguiente instrucción a ejecutar, y el registro de instrucciones (IR), que almacena 
          la instrucción actual que está siendo ejecutada. Otros ejemplos incluyen registros de datos y direcciones, utilizados para manejar las transferencias de datos y direcciones de memoria. 
          La estructura y función de estos registros son esenciales para el rendimiento y la eficiencia del procesador en la ejecución de tareas computacionales.
        </p>
      </article>
      <article id="RVU">
        <h2>2.2.1 Registros visibles para el usuario</h2>
        <img src="../U2/IMAGENES U2/tema3.jpg" alt="OP">
        <p>
          Los registros visibles para el usuario son aquellos registros que pueden ser directamente manipulados por las instrucciones de un programa durante su ejecución. 
          Estos registros permiten a los programadores y al código del sistema realizar operaciones aritméticas, lógicas y de control de flujo de manera eficiente. Un registro visible al usuario es aquél que puede ser referenciado por medio del lenguaje máquina que ejecuta la CPU. Prácticamente todos los diseños contemporáneos de CPUs están provistos de varios registros visibles al usuario, en oposición a disponer de un único acumulador.
          Podemos clasificarlos en:
          <h3><li>Registros de uso general:</li></h3>
          Los registros de uso general pueden ser asignados por el programador a diversas funciones. A veces, su uso dentro del repertorio de instrucciones es para contener el operando para cualquier código de operación.
          Esto proporciona una utilización de registros de auténtico uso general. Con frecuencia, sin embargo, existen restricciones.
          Por ejemplo, puede haber registros específicos para operaciones en coma flotante.
          En algunos casos los registros de uso general pueden ser utilizados para funciones de direccionamiento. 
          En otros casos hay una separación clara o parcial entre registros de datos y registros de direcciones.

          <h3><li>Registros de datos:</li></h3>
          Los registros visibles para el usuario son registros de propósito general y algunos registros especiales que los programas pueden utilizar directamente para realizar cálculos y manipular datos. 
          Estos registros son accesibles a través de las instrucciones del conjunto de instrucciones (ISA) de la CPU.
          Se utilizan para almacenar datos temporales, operandos y resultados de operaciones aritméticas y lógicas, así como para mantener direcciones de memoria y gestionar el flujo de control en los programas. 
          Su acceso rápido mejora significativamente el rendimiento de la CPU al reducir la necesidad de acceder a la memoria principal.
          <h3><li>Registros de direcciones:</li></h3>
          Los registros de dirección pueden ser en sí registros de uso más o menos general, o pueden estar dedicados a un modo de direccionamiento particular.
          El caso más conocido es el puntero a pila. La cantidad de registros generales o especializados es una cuestión de diseño.
          No hay solución óptima, pero la tendencia parece ir hacia el uso de registros especializados.
          Otro problema de diseño es el numero de registros, de uso general o de datos más direcciones, que tienen que incluirse.
          A mayor cantidad de registros se requieren mayor cantidad de bits en el campo de operando. Parece óptimo entre 8 y 32 registros.
          Menos registros se traducen en más referencias a memoria; más registros no reducen notablemente las referencias a memoria. Por último, está la cuestión de la longitud de los registros.
          Los registros que han de contener direcciones han de ser lo suficientemente grandes como para albergar la dirección más grande.

          <h3><li>Códigos de condiciones:</li></h3>
          Los códigos de condición son bits fijados por el hardware de la CPU como resultado de alguna operación.
          Por ejemplo, una operación aritmética puede producir un resultado positivo, negativo o nulo, o con desbordamiento.
          Además de almacenarse el propio resultado en un registro o en la memoria, se obtiene también un código de condición.
          Los bits de códigos de condición se reúnen en uno o más registros. Por lo general, forman parte de un registro de control.
          Comúnmente, las instrucciones de máquina permiten que estos bits sean leídos por referencia implícita, pero no pueden ser alterados por el programador.
        </p>
      </article>

      <article id="RCE">
        <h2>2.2.2 Registros de control y de estados</h2>
        <img src="../U2/IMAGENES U2/tema4.png" alt="RCE">
        <p>
          <h3><li>Registros de control:</li></h3>
          Hay diversos registros de la CPU que se pueden emplear para controlar su funcionamiento. 
          La mayoría de éstos, en la mayor parte de las máquinas, no son visibles al usuario. 
          Algunos de ellos pueden ser visibles a instrucciones de máquina ejecutadas en un modo de control o de sistema operativo.
          Naturalmente, máquinas diferentes tendrán diferentes organizaciones de registros y usará distinta terminología.
          Se enumera aquí una lista razonablemente completa de tipos de registros, con una breve descripción. 
          Son esenciales cuatro registros para la ejecución de una instrucción: el contador de programa, el registro de dirección, el registro de instrucción y el registro de datos.
          El contador de programa contiene una dirección de instrucción. Típicamente, la CPU actualiza el PC después de cada captación de instrucción de manera que siempre apunta a la siguiente instrucción a ejecutar. Una instrucción de bifurcación o salto también modificará el contenido de PC.
          La instrucción captada se carga en el registro de instrucción, donde son analizados el código de operación y los campos de operando.
          Se intercambian datos con la memoria por medio de registro de direcciones y el de datos. En un sistema con organización de bus, el de direcciones se conecta directamente al bus de direcciones, y el de datos directamente al bus de datos.
          Los registros visibles al usuario, sucesivamente, intercambian datos con el de datos. Los cuatro registros que acaban de mencionar se usan para la transferencia de datos entre la CPU y la memoria. Dentro de la CPU, los datos tienen que ofrecerse a la ALU para su procesamiento. La ALU puede tener acceso directo al de datos y a los registros visibles al usuario.
          Como alternativa, puede haber registros intermedios adicionales en el límite de la ALU; 
          estos registros sirven como registros de entrada y salida de la ALU e intercambian datos con el de datos y los registros visibles al usuario.

          <h3><li>Registros de estado:</li></h3>
          El registro de estado, también conocido como registro de bandera, palabra de estado del programa y registro de código de condición, se define como un conjunto de bits de bandera dentro de un procesador.
          Un registro es un circuito procesador y es muy parecido a una ubicación de memoria, lo que significa que los datos podrían escribirse y leerse.
          A diferencia de una ubicación de memoria, el registro de estado a menudo no tiene una dirección porque el microprocesador la usa internamente. En una unidad central de procesamiento (CPU) de 8 bits, se puede establecer un bit de registro de estado, igual al número 1, o borrar , igual al número 0, mediante una variedad de resultados de operación del procesador. El procesador a veces establece o borra los bits, pero otras veces, una instrucción de programa particular establece o borra los bits.
          Los bits de registro de estado también se denominan banderas o bits de bandera, y el programador los utiliza para ciertos fines de programación.
          Cada bandera en un registro de estado tiene un propósito único.
          El indicador de acarreo se establece si una operación anterior hizo que el séptimo bit - o indicador negativo - se desbordara, o hiciera que el indicador de transporte se desbordara. Se establece durante los cambios de lógica, comparación y aritmética. El indicador de cero se establece si el resultado de la operación más reciente fue 0.
          Un indicador llamado "deshabilitar interrupción" funciona permitiendo o deshabilitando la operación de interrupciones, que son instrucciones que detienen temporalmente ciertas operaciones para que se puedan realizar otras operaciones.
          Cuando se establece este indicador en particular, no se permite que funcionen las interrupciones, pero cuando está claro, se permiten las interrupciones. Otra bandera llamada bandera decimal permite al procesador seguir un modo binario más avanzado para realizar ecuaciones aritméticas impecables.
          Cuando se establece la bandera, utiliza este modo binario avanzado. Otro bit de registro es el bit de interrupción, que se establece cuando se ejecuta el comando Force Interrupt (BRK).
        </p>
      </article>
      <article id="EJR">
        <h2>2.2.3 Ejemplos de registros de CPU reales.</h2>
        <img src="../U2/IMAGENES U2/tema5.jpg" alt="OP">
        <p>
        
            <h3>Registro de Propósito General (General-Purpose Register):</h3>
            Este tipo de registro se utiliza para almacenar datos y realizar operaciones aritméticas y lógicas. 
            Los registros de propósito general son ampliamente utilizados en las CPUs modernas. Algunos ejemplos son:
            x86: EAX, EBX, ECX, EDX en la arquitectura Intel x86.
            ARM: R0, R1, R2, R3 en la arquitectura ARM.
          
          <h3>Registro de Puntero de Pila (Stack Pointer Register):</h3>
            Ayuda en la gestión de la pila de memoria utilizada para almacenar datos y direcciones de retorno durante las llamadas a funciones y las operaciones de salto. Algunos ejemplos son:
            x86: ESP (Extended Stack Pointer) en la arquitectura Intel x86.
            ARM: SP (Stack Pointer) en la arquitectura ARM.

            <h3>Registro de Contador de Programa (Program Counter Register):</h3>
            También conocido como PC, este registro almacena la dirección de la próxima instrucción a ejecutar en el programa. Controla el flujo de ejecución del programa. Algunos ejemplos son:
            x86: EIP (Extended Instruction Pointer) en la arquitectura Intel x86.
            ARM: PC (Program Counter) en la arquitectura ARM.

            <h3>Registro de Bandera/Estado (Flag/Status Register):</h3>
            También conocido como PC, este registro almacena la dirección de la próxima instrucción a ejecutar en el programa. Controla el flujo de ejecución del programa. Algunos ejemplos son:
            x86: EIP (Extended Instruction Pointer) en la arquitectura Intel x86.
            ARM: PC (Program Counter) en la arquitectura ARM. Este registro almacena información sobre el estado y los resultados de las operaciones realizadas por la CPU.
            Las banderas indican cosas como desbordamiento, igualdad, signo y otros indicadores de estado útiles para la ejecución de instrucciones condicionales. Algunos ejemplos son:
            x86: EFLAGS (Extended Flags Register) en la arquitectura Intel x86.
            ARM: CPSR (Current Program Status Register) en la arquitectura ARM.
            Estos son solo algunos ejemplos de registros utilizados en CPUs reales. Ten en cuenta que las arquitecturas de procesadores pueden variar y tener conjuntos de registros diferentes. 
            Además, algunas arquitecturas pueden tener registros especializados para funciones específicas, 
            como registros de punto flotante para operaciones de coma flotante o registros de vector para instrucciones SIMD (Single Instruction, Multiple Data).
        </p>
      </article>
      <article id="CI">
        <h2>2.3 El ciclo de instrucción</h2>
        <img src="../U2/IMAGENES U2/tema6.webp" alt="CI">
        <p>
          <h3>Ciclos de la computadora:</h3>
          La búsqueda es el proceso de obtener instrucciones de un programa o un elemento de datos de la memoria.
          El término decodificar se refiere al proceso de traducir las instrucciones a señales que la computadora puede ejecutar.
          Ejecutar es el proceso de llevar a cabo los comandos. Almacenamiento en este contexto significa escribir el resultado a la memoria.
          En algunas computadoras, el procesador busca, decodifica, ejecuta y almacena solo una instrucción a la vez.
          En estas computadoras el procesador espera hasta que una instrucción completa las cuatro etapas del ciclo antes de iniciar a trabajar con la siguiente instrucción.
          Hoy día la mayoría de las computadoras personales soportan un concepto llamado pipelining:
          Con pipelining los procesadores inician la búsqueda de una segunda instrucción antes de que se haya completado el ciclo de la computadora de la primera instrucción. 
          Los procesadores que cuentan con pipelining habilitado 
          son más rápidos en el procesamiento porque no tienen que esperar para que una instrucción complete el ciclo de computadora antes de buscar la siguiente.
        </p>
      </article>
      <article id="CIF">
        <h2>2.3.1 Ciclo Fetch-Decode-Execute</h2>
        <img src="../U2/IMAGENES U2/tema7.jpg" alt="OP">
        <p>
          El encargado de ejecutar un programa en una computadora u otro sistema computacional es el CPU, lo realiza siguiendo el llamado ciclo Fetch Decode Execute, con este ciclo se ejecutan todas las tareas que una computadora puede realizar.
          Este ciclo tiene algunas variantes y conforme ha avanzado el tiempo y la tecnología ha sufrido algunos cambios, pero el ciclo básico se conforma de las siguientes etapas:

          <h3>1. Traer la instrucción:</h3>
          Se obtiene la instrucción desde memoria y se almacena en el registro del CPU para instrucciones.

          <h3>2. Decodificar la instrucción:</h3>
          Se identifica el modo de direccionamiento de la instrucción y la ubicación de los datos a tratar, ya sea de
          memoria, registro o instrucción directamente.

          <h3>3. Carga de Parámetros:</h3>
          Se ejecuta la lectura, cargando todos los datos identificados en el paso anterior.

          <h3>4. Ejecutar:</h3>
          Se ejecuta la instrucción ya configurada, realiza la tarea indicada, ya sea una suma, resta, almacenar información, extraer
          información etc.

          <h3>5. Almacenar: </h3>
          Se almacena el resultado obtenido de ejecutar la instrucción, por ejemplo, el resultado de una suma o un índice (Número)
          como resultado de éxito de almacenar u obtener información de un archivo, entre otros.

          <h3>6.Actualizar PC: </h3>
          Esta etapa es la de actualizar el registro PC (Program Counter) que contiene la siguiente dirección a ejecutar.
          Evidentemente al ser un ciclo estas etapas se repiten constantemente durante el funcionamiento de la computadora.
          Se debe considerar que el ciclo expuesto anteriormente es muy básico. Como se mencionaba hoy en día estos ciclos han tenido algunas alteraciones y optimizado de gran manera, 
          como se sabe los sistemas de hoy en día son multitareas, lo cual conlleva a una alteración en este ciclo, 
          además de las diferentes técnicas para reducir el tiempo de ejecución de instrucciones con temas de concurrencia y paralelismo en los procesadores modernos.
          El ciclo expuesto nos muestra un poco la forma en la que las computadoras funcionan, todo el proceso que conlleva ejecutar una instrucción que puede parecer muy simple, además este ciclo básico permite darse una idea de cómo ha evolucionado los procesadores 
          y las técnicas para reducir el tiempo de ejecución dado que los sistemas actuales ejecutan de forma simultánea muchas veces este ciclo, siendo este modificado y más eficiente.
          Se ejecuta la lectura, cargando todos los datos identificados en el paso anterior.
        </p>
      </article>
      <article id="SI">
        <h2>2.3.2 Segmentación de instrucciones</h2>
        <img src="../U2/IMAGENES U2/tema8.jpeg" alt="CI">
        <p>
          La segmentación (en inglés pipelining, literalmente 'tubería' o 'cañería', o data pipeline) es un método por el cual se consigue aumentar el rendimiento de algunos sistemas electrónicos digitales. Se usa principalmente en los microprocesadores.
          El nombre, por analogía, viene de que para impulsar el gas en un oleoducto a la máxima velocidad posible es necesario dividir el oleoducto en tramos y colocar una bomba que dé un
          nuevo impulso al gas.
          El símil con la programación existe en que los cálculos deben ser registrados o sincronizados con el reloj cada cierto tiempo para que la ruta crítica (tramo con más carga o retardo computacional entre dos registros de reloj) se reduzca.
          La ruta crítica es en realidad la frecuencia máxima de trabajo alcanzada por el conjunto. A mayor ruta crítica (tiempo o retraso entre registros) menor es la frecuencia máxima de trabajo y a menor ruta crítica mayor frecuencia de trabajo. La una es la inversa de la otra. Repartir o segmentar equitativamente el cálculo hace que esa frecuencia sea la óptima a costa de más área para el almacenamiento o registro de los datos intervinientes y de un retraso o latencia (en ciclos de reloj/tiempo) en la salida del resultado equivalente al número de segmentaciones o registros realizados.
          La ventaja primordial de este sistema es que, tal y como se muestra en la imagen, una vez el canal (pipe) está lleno, es decir, después de una latencia de cuatro en la imagen, los resultados de cada comando vienen uno tras otro cada flanco de reloj y sin latencia extra por estar encadenados dentro del mismo canal.
          Todo esto habiendo maximizado la frecuencia máxima de trabajo.
        </p>
      </article>
      <article id="CICF">
        <h2>2.3.3 Conjunto de instrucciones, Caracteristicas y funciones</h2>
        <img src="../U2/IMAGENES U2/tema9.png" alt="CI">
        <p>
          Un conjunto de instrucciones o repertorio de instrucciones, juego de instrucciones o ISA (del inglés Instruction Set Architecture, Arquitectura del Conjunto de Instrucciones) es una especificación que detalla las instrucciones que una CPU de un ordenador puede entender y ejecutar, o el conjunto de todos los comandos implementados por un diseño particular de una CPU.
          El término describe los aspectos del procesador generalmente visibles a un programador, incluyendo los tipos de datos nativos, las instrucciones, los registros, la arquitectura de memoria y las interrupciones, entre otros aspectos.
          Existe principalmente de 3 tipos: CISC (Complex Instruction Set Computer), RISC (Reduced Instruction Set Computer) y SISC (Specific Instruction Set Computer).
          La arquitectura del conjunto de instrucciones (ISA) se emplea a veces para distinguir este conjunto de características de la microarquitectura, que son los elementos y técnicas que se emplean para implementar el conjunto de instrucciones. Entre estos elementos se encuentras las microinstrucciones y los sistemas de caché.
          Procesadores con diferentes diseños internos pueden compartir un conjunto de instrucciones; por ejemplo el Intel Pentium y AMD Athlon implementan versiones casi idénticas del conjunto de instrucciones x86, aunque tienen diseños internos completamente opuestos.
        </p>
      </article>

      <article id="MD">
        <h2>2.3.4 Modos de direccionamiento</h2>
        <img src="../U2/IMAGENES U2/tema10.jpg" alt="CI">
        <p>
          <h3>1. Inmediato (Immediate)</h3>
          En este modo de direccionamiento, el valor del operando se especifica directamente en la instrucción. Por ejemplo, la instrucción ADD R1, #10 suma el valor inmediato 10 al contenido del registro R1.
          son más rápidos en el procesamiento porque no tienen que esperar para que una instrucción complete el ciclo de computadora antes de buscar la siguiente.
          <h3>2.Directo (Direct)</h3>
          En este modo, la dirección de memoria del operando se especifica directamente en la instrucción. 
          Por ejemplo, la instrucción LOAD R2, [100] carga el valor almacenado en la dirección de memoria 100 en el registro R2.
          <h3>3. Indirecto (Indirect)</h3>
          En este modo, la dirección de memoria del operando se obtiene indirectamente a través de un registro o puntero. Por ejemplo, la instrucción LOAD R3, 
          [R2] carga el valor almacenado en la dirección de memoria apuntada por el contenido del registro R2 en el registro R3.
          <h3>4. Basado en Registro (Register-based)</h3>
          En este modo, la dirección de memoria del operando se calcula sumando un desplazamiento a un registro base. Por ejemplo, la instrucción LOAD R4, [R5+10] carga el valor almacenado en la dirección de memoria calculada sumando 10 al contenido del registro R5 en el registro R4.
          <h3>5. Indexado (Indexed)</h3>
          En este modo, la dirección de memoria del operando se calcula sumando un desplazamiento a un registro índice. Por ejemplo, la instrucción LOAD R6, [R7+R8] carga el valor almacenado en la dirección de memoria calculada sumando el contenido del registro R8 al contenido del registro R7 en el registro R6.
          <h3>6. Relativo (Relative)</h3>
          Este modo se utiliza en instrucciones de salto o branch. La dirección de salto se calcula sumando un desplazamiento relativo a la dirección de la siguiente instrucción. Por ejemplo, la instrucción JUMP [PC+20] realiza un salto a la dirección de memoria calculada sumando 20 al contenido del contador de programa (PC).
        </p>
      </article>

      <article id="CCPUR">
        <h2>2.4 Casos de estudio de CPU reales</h2>
        <img src="../U2/IMAGENES U2/tema11.jpg" alt="CI">
        <p>
          En informática, los modos de direccionamiento son las diferentes maneras de especificar un operando dentro de una instrucción en lenguaje ensamblador.
Un modo de direccionamiento especifica la forma de calcular la dirección de memoria efectiva de un operando mediante el uso de la información contenida en registros y/o constantes, contenida dentro de una instrucción de la máquina o en otra parte.
No existe una forma generalmente aceptada de nombrar a los distintos modos de direccionamiento. En particular, los distintos autores y fabricantes de equipos pueden dar nombres diferentes para el modo de hacer frente al mismo, o los mismos nombres, a los diferentes modos de direccionamiento.
Además, un modo de direccionamiento que en una determinada arquitectura se trata como un modo de direccionamiento, puede representar la funcionalidad que en otra arquitectura está cubierto por dos o más modos de direccionamiento.
        </p>
      </article>

     <script src="U2.js"></script>
      <script>
        function toggleMenu() {
          var menu = document.getElementById('sidebar-menu');
          menu.classList.toggle('collapsed');
        }
      </script>
    </body>
    </html>